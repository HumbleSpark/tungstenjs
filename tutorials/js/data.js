var todo = {template: '<div class="todoapp">\n  <header class="header">\n    <h1>todos</h1>\n    <!-- todoapp -->\n    <input placeholder="What needs to be done?" type="text" autofocus="true" class="new-todo js-new-todo">\n  </header>\n  <section class="main">\n    <input class="toggle-all js-toggle-all" type="checkbox" {{#allCompleted}}checked="checked"{{/allCompleted}}>\n    <label for="toggle-all">Mark all as complete</label>\n    <ul class="todo-list js-todo-list">\n    {{#todoItems}}\n    {{^hidden}}\n      <li class="js-todo-item {{#completed}} completed {{/completed}} {{#editing}} editing {{/editing}}">\n      <!-- {{title}} -->\n      {{^editing}}\n        <div class="view">\n          <input class="toggle js-toggle" type="checkbox" {{#completed}}checked="checked"{{/completed}}>\n          <label class="js-todo-title">{{title}}</label>\n          <button class="destroy js-destroy"></button>\n        </div>\n      {{/editing}}\n      {{#editing}}\n      <input class="edit js-todo-edit" value="{{title}}">\n      {{/editing}}\n    </li>\n  {{/hidden}}\n\n        {{/todoItems}}\n  </ul>\n  </section>\n  {{#hasTodos}}\n  <footer class="footer">\n  <span class="js-todo-count todo-count"><strong>{{todoCount}}</strong> item{{#todoCountPlural}}s{{/todoCountPlural}} left</span>\n  {{#hasCompleted}}\n  <button class="clear-completed js-clear-completed">Clear completed</button>\n  {{/hasCompleted}}\n  </footer>\n  {{/hasTodos}}\n</div>', js: "var View = tungsten.backbone.View, Model = tungsten.backbone.Model, Collection = tungsten.backbone.Collection;\nvar ENTER_KEY = 13;\nvar ESC_KEY = 27;\nvar TodoItemView = View.extend({\n  events: {\n    'blur .js-todo-edit': 'handleBlurTodoEdit',\n    'click .js-toggle': 'handleClickToggle',\n    'click .js-destroy': 'handleClickDestroy',\n    'dblclick .js-todo-title': 'handleDblClickTodoTitle',\n    'keydown .js-todo-edit': 'handleKeyDownTodoEdit',\n    'keypress .js-todo-edit': 'handleKeyPressTodoEdit'\n  },\n  handleBlurTodoEdit: function(e) {\n    if (!this.model.get('editing')) {\n      return;\n    }\n    this.clear(e.currentTarget);\n  },\n  handleClickDestroy: function() {\n    this.model.destroy();\n  },\n  handleClickToggle: function() {\n        console.log(this.model);\n    this.model.toggle();\n  },\n  handleDblClickTodoTitle: function(e) {\n    this.model.set('editing', true);\n    e.currentTarget.focus();\n  },\n  handleKeyDownTodoEdit: function(e) {\n    if (e.which === ESC_KEY) {\n      this.model.set('editing', false);\n      this.model.set('title', this.model.get('title'));\n    }\n  },\n  handleKeyPressTodoEdit: function(e) {\n    if (e.which === ENTER_KEY) {\n      this.clear(e.currentTarget);\n    }\n  },\n  clear: function(input) {\n    var value = input.value;\n\n    var trimmedValue = value.trim();\n\n    if (trimmedValue) {\n      this.model.set({ title: trimmedValue });\n      input.value = '';\n      this.model.set('editing', false);\n      if (value !== trimmedValue) {\n        this.model.trigger('change');\n      }\n    } else {\n      this.handleClickDestroy();\n    }\n  }\n}, {\n  debugName: 'TodoItemView'\n});\n\nvar NewItemView = View.extend({\n  events: {\n    'keyup': 'handleKeyup'\n  },\n  handleKeyup: function(e) {\n    if (e.which === ENTER_KEY && e.currentTarget.value !== '') {\n      this.model.trigger('addItem', e.currentTarget.value.trim());\n      this.el.value = '';\n    }\n  }\n}, {\n  debugName: 'NewTodoItemView'\n});\n\nvar AppView = View.extend({\n  childViews: {\n    'js-new-todo': NewItemView,\n    'js-todo-item': TodoItemView\n  },\n  events: {\n    'click .js-toggle-all': 'handleClickToggleAll',\n    'click .js-clear-completed': 'handleClickClearCompleted'\n  },\n  handleClickClearCompleted: function() {\n    _.invoke(this.model.get('todoItems').where({completed: true}), 'destroy');\n    return false;\n  },\n  handleClickToggleAll: function(e) {\n    var completed = e.currentTarget.checked;\n    this.model.get('todoItems').each(function(item) {\n      item.set('completed', completed);\n    });\n  }\n}, {\n  debugName: 'TodoAppView'\n});\nvar ItemModel = Model.extend({\n  toggle: function() {\n    this.set({\n      completed: !this.get('completed')\n    });\n  }\n});\nvar ItemCollection = Collection.extend({\n  model: ItemModel\n});\nvar AppModel = Model.extend({\n  relations: {\n    todoItems: ItemCollection\n  },\n  defaults: {\n    todoItems: [],\n  },\n  postInitialize: function() {\n    this.listenTo(this, 'addItem', function(title) {\n      // @todo add code to clear toggle-all button\n      this.get('todoItems').add({title: title});\n    });\n  },\n  derived: {\n    hasTodos: {\n      deps: ['todoItems'],\n      fn: function() {\n        return this.get('todoItems').length > 0;\n      }\n    },\n    incompletedItems: {\n      deps: ['todoItems'],\n      fn: function() {\n        return this.get('todoItems').filter(function(item) {\n          return !item.get('completed');\n        });\n      }\n    },\n    allCompleted: {\n      deps: ['todoItems'],\n      fn: function() {\n        if (this.get('todoItems').length) {\n          return this.get('todoItems').every(function(item) {\n            return item.get('completed');\n          });\n        }\n      }\n    },\n    todoCount: {\n      deps: ['incompletedItems'],\n      fn: function() {\n        return this.get('incompletedItems').length;\n      }\n    },\n    todoCountPlural: {\n      deps: ['todoCount'],\n      fn: function() {\n        return this.get('todoCount') !== 1;\n      }\n    },\n    hasCompleted: {\n      deps: ['todoItems'],\n      fn: function() {\n        return this.get('todoItems').length - this.get('incompletedItems').length > 0;\n      }\n    }\n  }\n});\n\nnew AppView({\n    el: '#app',\n    template: compiledTemplates.app_view,\n    model: new AppModel(),\n    dynamicInitialize: true\n});"};

window.data = {
  tutorials: [{
    name: 'Hello World',
    steps: [{
      name: 'Hello Tungsten.js!',
      index: 1,
      template_highlights: [{start: {line: 0, ch: 6}, end: {line: 0, ch: 12}}],
      description_html: '<p>Welcome to the first tutorial on how to use Tungsten.js!  Use the steps above to navigate through each step of each tutorial.  On the top right is the mustache template for the step, and on the bottom right is the JavaScript code; together these make up your Tungsten.js application.  On the bottom left is the output of this applicaton.  After editing the code, click the run button below to update the output.  Or, press ctrl+enter while editing.</p><p>Alright, let\'s start.  Because Tungsten.js uses plain mustache templates, you can update the HTML in the template to update HTML in the application.  Change the HTML in the template to output text "Hello!" instead of "Hello?".  Then, change the <code>span</code> element to a <code>strong</code> element.</p>',
      template: '<span>Hello?</span>',
      js: "var View = tungsten.backbone.View, Model = tungsten.backbone.Model;\nnew View({\n  el: '#app',\n  template: compiledTemplates.app_view,\n  model: new Model({name: 'world'}),\n  dynamicInitialize: true \n});"
    },{
      name: 'Adding dynamic content',
      index: 2,
      template_highlights: [{start: {line: 0, ch: 8}, end: {line: 0, ch: 14}}],
      js_highlights: [{start: {line: 4, ch: 19}, end: {line: 4, ch: 34}}],
      description_html: '<p>Now let\'s add a dynamic value to the template.  In mustache (and so also in Tungsten.js), this is done with "tags" denoted by double braces, e.g., <code>{{ this_is_a_tag }}</code></p><p>Data for our templates is injected from our model.  Here, the property <code>name</code> (with the value "world") has been added to our model.</p><p>Add <code>name</code> to the template HTML after hello, so that the output reads, "Hello, World!".</p>',
      template: '<strong>Hello!</strong>',
      js: "var View = tungsten.backbone.View, Model = tungsten.backbone.Model;\nnew View({\n  el: '#app',\n  template: compiledTemplates.app_view,\n  model: new Model({name: 'world'}),\n  dynamicInitialize: true \n});"
    },{
      name: 'Looping through an array',
      index: 3,
      description_html: '<p>We can loop through a list of values in mustache using <code>section</code> tags which are denoted by double braces and prefixed with <code>#</code> for the start tag, and <code>/</code> for the end tag, e.g. <code>{{#section_starts}}{{/section_ends}}</code>.  While looping through an array, a single period in double braces (<code>{{ . }}</code>) indicates that current item in the loop should be output.</p><p>Here, the property <code>names</code> has been added to our model as an array of strings.</p><p>Add a <code>names</code> section to the template, and use <code>{{ . }}</code> to output each item to the unordered list.</p>',
      template: '<ul><li></li></ul>',
      js: "var View = tungsten.backbone.View, Model = tungsten.backbone.Model;\nnew View({\n  el: '#app',\n  template: compiledTemplates.app_view,\n  model: new Model({names: ['George Washington', 'John Adams', 'Thomas Jefferson', 'James Madison', 'James Monroe']}),\n  dynamicInitialize: true \n});"
    }

    ]
  },
    {
      name: 'Views & Context',
      steps: [{
        name: 'Adding a child view',
        index: 1,
        js_highlights: [{start: {line: 10, ch: 2}, end: {line: 10, ch: 17}}],
        template_highlights: [{start: {line: 0, ch: 5}, end: {line: 0, ch: 10}}],
        description_html: '<p>The standard adaptor for Tungsten.js uses Backbone.js views and models. This adaptor adds a few features to Backbone, including the concept of child views. Child views of the app view are defined via a <code>childViews</code> hash on the view constructor, with the key being the class name of the child view and the value being the constructor for the child view. One thing to note is that these class names must be prefixed with "js-".  The js- class name for the child view must be a descendant element of the current view.  If there are multiple descendant elements for the child view then Tungsten.js will render the view for each element.</p><p>Here, a view constructor has been created with a click event to toggle a class on the block.  However, the view hasn\'t yet been set as a child view.</p><p>Wire the child view up to the application view by giving each block <code>div</code> a "js-" class name and adding that class name, with the <code>BlockView</code> view constructor, to the <code>childViews</code> hash.  The result should be that clicking a block toggles every block\'s background color to red.</p>',
        template: '<div class="block {{#selected}}selected{{/selected}}">Block View</div>\n<div class="block {{#selected}}selected{{/selected}}">Block View</div>\n\n<style> .block { background: lightgray; height: 50px; margin: 10px; width: 90%; text-align: center; line-height: 50px;} .selected { background: red; } </style>',
        js: "var View = tungsten.backbone.View, Model = tungsten.backbone.Model;\nvar BlockView = View.extend({\n  events: {\n    'click': 'handleClick'\n  },\n  handleClick: function() {\n    this.model.set('selected', !this.model.get('selected'));\n  }\n});\nvar AppView = View.extend({\n  childViews: {}\n});\nnew AppView({\n  el: '#app',\n  template: compiledTemplates.app_view,\n  model: new Model(),\n  dynamicInitialize: true\n});"
      },{
        name: 'Template context',
        index: 2,
        template_highlights: [{start: {line: 1, ch: 65}, end: {line: 1, ch: 75}}],
        description_html: '<p>Variables in Tungsten.js mustache templates are interpolated based on normal mustache mechanics.  The injected data for each template is generated by serializing the application model.</p><p>Here, the model\'s data has been set to an array with two objects, each having a <code>name</code> property.  Two blocks are being generated by looping over this array. Using a mustache variable, add the block names to the template.</p>',
        template: '{{#blocks}}\n  <div class="block js-block {{#selected}}selected{{/selected}}">Block View</div>\n{{/blocks}}\n\n<style> .block { background: lightgray; height: 50px; margin: 10px; width: 90%; text-align: center; line-height: 50px;} .selected { background: red; } </style>',
        js: "var View = tungsten.backbone.View, Model = tungsten.backbone.Model;\nvar BlockView = View.extend({\n  events: {\n    'click': 'handleClick'\n  },\n  handleClick: function() {\n    this.model.set('selected', !this.model.get('selected'));\n  }\n});\nvar AppView = View.extend({\n  childViews: {\n    'js-block': BlockView\n}\n});\nnew AppView({\n  el: '#app',\n  template: compiledTemplates.app_view,\n  model: new Model({blocks: [{name: 'foo'}, {name: 'bar'}]}),\n  dynamicInitialize: true\n});"
      },{
        name: 'Child view context',
        index: 3,
        js_highlights: [{start: {line: 10, ch: 2}, end: {line: 10, ch: 15}}],
        description_html: '<p>Tungsten.js infers the context, the <code>this.model</code> value, of a child view based on the template section tags.  If the section tags around a child view match a property which is another model, for example, the view\'s <code>this.model</code> will be that matching model.  If the section tags around a child view match a property which is a collection, each view which is rendered as the result of iterating through a collection will have its <code>this.model</code> match the appropriate model in the collection.</p><p>In standard Backbone.js, there <a href="http://backbonejs.org/#FAQ-nested" target="_blank">is no standard method for nesting models or collections</a>.  The Backbone adaptor for Tungsten.js uses a fork of <a href="https://github.com/blittle/backbone-nested-models" target="_blank">Backbone Nested Models</a> to add this feature.  To set a nested model or collection, add the property of the nested object (or array of objects if nesting a collection) as the key on the parent model\'s <code>relations</code> hash.  Then set its value as the constructor for the collection or model</p><p>In this example, the click event on each of the blocks works, but since <code>blocks</code> is not a Backbone collection, each view just gets the app model context and so both blocks turn red when clicking on either one.</p><p>Wire up the `blocks` property on the app model so that it\'s a collection.  Doing so should give each child view the context of the model in the collection, so clicking one block will only turn it red, not all the others.</p>',
        template: '{{#blocks}}\n  <div class="block js-block {{#selected}}selected{{/selected}}">Block View | {{name}}</div>\n{{/blocks}}\n\n<style> .block { background: lightgray; height: 50px; margin: 10px; width: 90%; text-align: center; line-height: 50px;} .selected { background: red; } </style>',
        js: "var View = tungsten.backbone.View, Model = tungsten.backbone.Model;\nvar BlockView = View.extend({\n  events: {\n    'click': 'handleClick'\n  },\n  handleClick: function() {\n    this.model.set('selected', !this.model.get('selected'));\n  }\n});\nvar AppModel = Model.extend({\n  relations: {}\n});\nvar AppView = View.extend({\n  childViews: {\n    'js-block': BlockView\n}\n});\nnew AppView({\n  el: '#app',\n  template: compiledTemplates.app_view,\n  model: new AppModel({blocks: [{name: 'foo'}, {name: 'bar'}]}),\n  dynamicInitialize: true\n});"
      }
      ]
    },
    {
    name: 'TodoMVC',
    steps: [
      {
        name: 'TodoMVC Example',
        index: 1,
        description_html: 'There are no steps for this example, just a demo of TodoMVC.',
        template: todo.template,
        js: todo.js
      }
    ]
  }]
};